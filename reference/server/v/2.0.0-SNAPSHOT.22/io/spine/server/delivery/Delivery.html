<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Delivery (server 2.0.0-SNAPSHOT.22 API)</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Delivery (server 2.0.0-SNAPSHOT.22 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":9,"i2":9,"i3":9,"i4":10,"i5":10,"i6":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/spine/server/delivery/CommandEndpoint.html" title="interface in io.spine.server.delivery"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../io/spine/server/delivery/DeliveryBuilder.html" title="class in io.spine.server.delivery"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/spine/server/delivery/Delivery.html" target="_top">Frames</a></li>
<li><a href="Delivery.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.spine.server.delivery</div>
<h2 title="Class Delivery" class="title">Class Delivery</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.spine.server.delivery.Delivery</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>io.spine.logging.Logging</dd>
</dl>
<hr>
<br>
<pre>public final class <span class="typeNameLabel">Delivery</span>
extends java.lang.Object
implements io.spine.logging.Logging</pre>
<div class="block">Delivers the messages to the entities.

 <p>Splits the incoming messages into shards and allows to deliver the
 messages to their destinations on a per-shard basis. Guarantees that one and only one
 application server node serves the messages from the given shard at a time, thus preventing
 any concurrent modifications of entity state.

 <p>Delegates the message dispatching and low-level handling of message duplicates to
 <a href="../../../../io/spine/server/delivery/Delivery.html#newInbox-io.spine.type.TypeUrl-"><code>Inbox</code></a>es of each target entity. The respective <code>Inbox</code> instances
 should be created in each of <code>Entity</code> repositories.

 <h1>Configuration</h1>

 <h2>Delivery Strategy</h2>

 <p>By default, a shard is assigned according to the identifier of the target entity. The
 messages heading to a single entity will always reside in a single shard. However,
 the framework users may <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setStrategy-io.spine.server.delivery.DeliveryStrategy-">customize</a>
 this behavior.

 <p>The typical customization would be to specify the same shard index for the related targets.
 E.g. if there is an <code>OrderAggregate</code>, <code>OrderItemAggregate</code>
 and <code>OrderItemProjection</code>, they could share the same shard index. In this way the messages
 headed to these entities will be dispatched and processed together. In turn, that will reduce
 the eventual consistency lag between <code>C</code> side (i.e. aggregate state updates)
 and <code>Q</code> side (i.e. the respective updates in projections).

 <h2>Deduplication</h2>

 <p>As long as the underlying storage and transport mechanisms are restricted by the CAP theorem,
 there may be duplicates in the messages written, read or dispatched. The <code>Delivery</code>
 responds to it by storing some of the already delivered messages for longer and using them as
 a source for deduplication.

 <p><a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setDeduplicationWindow-com.google.protobuf.Duration-">Provides</a> the time-based
 deduplication capabilities to eliminate the messages, which may have been already delivered
 to their targets. The duplicates will be detected among the messages, which are not older, than
 <code>now - [deduplication window]</code>.

 <h2>Customizing <code>InboxStorage</code></h2>

 <p><code>Delivery</code> is responsible for providing the <a href="../../../../io/spine/server/delivery/InboxStorage.html" title="class in io.spine.server.delivery"><code>InboxStorage</code></a> for every inbox
 registered. Framework users may <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setInboxStorage-io.spine.server.delivery.InboxStorage-">configure</a> the storage. By default, the <code>InboxStorage</code> for the delivery is provided
 by the environment-specific <a href="../../../../io/spine/server/ServerEnvironment.html#storageFactory--">storage factory</a>
 and is single-tenant. In case there is at least one multi-tenant <code>BoundedContext</code>
 served by the <code>Delivery</code>, the <code>InboxStorage</code> should be configured
 to support the multi-tenancy.

 <h2>Catch-up</h2>

 <p>In addition to delivering the messages sent in a real-time, <code>Delivery</code> dispatches
 the historical events sent to the catching-up projections. These events are dispatched through
 the same shards as the live messages. A special <code>CatchUpStation</code> is responsible for
 handling this use-case. See more on that in the respective section.

 <p>To control how many historical events are read and put into shards, the end-users may
 configure the <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setCatchUpPageSize-int-">maximum number of messages</a>
 read from the history at a time. This is helpful to balance the per-shard throughput, so
 that the live messages are still dispatched through the same shards in a reasonable time.

 <p>The statuses of the ongoing catch-up processes are stored in a dedicated
 <a href="../../../../io/spine/server/delivery/CatchUpStorage.html" title="class in io.spine.server.delivery"><code>CatchUpStorage</code></a>. The <code>DeliveryBuilder</code> <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setCatchUpStorage-io.spine.server.delivery.CatchUpStorage-">exposes an API</a> for the customization of this
 storage. By default, the <code>CatchUpStorage</code> is single-tenant. However,
 as with the <code>InboxStorage</code> used by the <code>Delivery</code>, it should be configured
 as multi-tenant if at least one <code>BoundedContext</code> served by the <code>Delivery</code>
 is multi-tenant.

 <h2>Observers</h2>

 <p>Once a message is written to the <code>Inbox</code>,
 the <a href="../../../../io/spine/server/delivery/Delivery.html#subscribe-io.spine.server.delivery.ShardObserver-">pre-configured shard observers</a> are
 <a href="../../../../io/spine/server/delivery/ShardObserver.html#onMessage-io.spine.server.delivery.InboxMessage-">notified</a>. In this way any third-party
 environment planners, load balancers, and schedulers may plug into the delivery and perform
 various routines to enable the further processing of the sharded messages. In a distributed
 environment a message queue may be used to notify the node cluster of a shard that has some
 messages pending for the delivery.

 <h2>Work registry</h2>

 <p>Once an application node picks the shard to deliver the messages from it, it registers itself
 in a <a href="../../../../io/spine/server/delivery/ShardedWorkRegistry.html" title="interface in io.spine.server.delivery"><code>ShardedWorkRegistry</code></a>. It serves as a list of locks-per-shard that only allows
 to pick a shard to a single node at a time. The framework users may configure the implementation
 of the registry by calling <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setWorkRegistry-io.spine.server.delivery.ShardedWorkRegistry-"><code>DeliveryBuilder.setWorkRegistry(ShardedWorkRegistry)</code></a>.

 <h2>Dispatching messages</h2>

 <h3>Delivery stages</h3>

 <p>The delivery process for each shard index is split into <code>DeliveryStage</code>s. In scope of
 each stage, a certain number of messages is read from the respective shard of the <code>Inbox</code>.
 The messages are grouped per-target and delivered in batches if possible. The maximum
 number of the messages within a <code>DeliveryStage</code> can be
 <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setPageSize-int-">configured</a>.

 <p>After each <code>DeliveryStage</code> it is possible to stop the delivery by
 <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setMonitor-io.spine.server.delivery.DeliveryMonitor-"><code>supplying</code></a> a custom delivery monitor.
 Please refer to the <a href="../../../../io/spine/server/delivery/DeliveryMonitor.html" title="class in io.spine.server.delivery"><code>documentation</code></a> for the details.

 <h3>Conveyor and stations</h3>

 <p>In a scope of <code>DeliveryStage</code> the page of the <code>InboxMessage</code>s is placed
 to the <code>Conveyor</code> responsible for tracking the status of each message.
 The conveyor is run through the pipeline of stations, each modifying the state of the messages.
 At the end of the pipeline, the changed made to the messages are committed to the underlying
 <code>InboxStorage</code> in a bulk. Such an approach allows to minimize the number of the requests
 sent to the storage.

 <p>As long as the new <code>DeliveryStage</code> is started, the new instance of the <code>Conveyor</code>
 is created.

 <p>Below is the list of the conveyor stations in the pipeline.

 <b>1. Catch-up station</b>

 <p>This station is responsible for dispatching the historical events in
 <code>TO_CATCH_UP</code> status to the respective targets. Also,
 while the target entity is under a catch-up, all the live messages headed to it are ignored.
 Once the catch-up is completed, this station handles the transition period, in which the last
 batch of the historical events and live messages are dispatched together.
 See <code>CatchUpStation</code> for more details.

 <b>2. Live delivery station</b>

 <p>This station is responsible for dispatching the messages sent in a real-time. It ignores
 the messages in <code>TO_CATCH_UP</code> status. Another responsibility
 of this station is to set for how long the delivered messages should be kept according to the
 <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html#setDeduplicationWindow-com.google.protobuf.Duration-">deduplication window</a> settings.
 See <code>LiveDeliveryStation</code> for more details.

 <b>3. Cleanup station</b>

 <p>This station removes the messages which are already delivered and are no longer needed for the
 deduplication. See <code>CleanupStation</code> for the description.

 <b>Deduplication</b>

 <p>During the dispatching, <code>Conveyor</code> keeps track of the delivered messages. The stations
 performing the actual message dispatching rely onto this knowledge and deduplicate
 the messages prior to calling the target's endpoint.

 <p>Additionally, the <code>Delivery</code> provides a cache of recently
 delivered messages. Each instance of the <code>Conveyor</code> has an access to it and uses it
 in deduplication procedures.

 <h2>Local environment</h2>

 <p>By default, the delivery is configured to <a href="../../../../io/spine/server/delivery/Delivery.html#local--">run locally</a>. It
 uses <a href="../../../../io/spine/server/delivery/LocalDispatchingObserver.html" title="class in io.spine.server.delivery">see-and-dispatch observer</a>, which delivers the
 messages from the observed shard once a message is passed to its
 <a href="../../../../io/spine/server/delivery/LocalDispatchingObserver.html#onMessage-io.spine.server.delivery.InboxMessage-"><code>onMessage(InboxMessage)</code></a> method. This
 process is synchronous.

 <p>To deal with the multi-threaded access in a local mode,
 an <a href="../../../../io/spine/server/delivery/memory/InMemoryShardedWorkRegistry.html" title="class in io.spine.server.delivery.memory">InMemoryShardedWorkRegistry</a> is used. It operates on top of the
 <code>synchronized</code> in-memory data structures and prevents several threads from picking up the
 same shard.

 <h2>Shard maintenance</h2>

 <p>To perform the maintenance procedures, the <code>Delivery</code> requires all the <code>BoundedContext</code>s to register themselves in it. Upon this registration, a special
 <code>ShardMaintenanceProcess</code> is registered as an event dispatcher in a passed
 <code>BoundedContext</code>. Such a registration is performed automatically when the context is
 <a href="../../../../io/spine/server/BoundedContextBuilder.html#build--">built</a>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>java.util.Optional&lt;<a href="../../../../io/spine/server/delivery/DeliveryStats.html" title="class in io.spine.server.delivery">DeliveryStats</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../io/spine/server/delivery/Delivery.html#deliverMessagesFrom-io.spine.server.delivery.ShardIndex-">deliverMessagesFrom</a></span>(io.spine.server.delivery.ShardIndex&nbsp;index)</code>
<div class="block">Delivers the messages put into the shard with the passed index to their targets.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static <a href="../../../../io/spine/server/delivery/Delivery.html" title="class in io.spine.server.delivery">Delivery</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../io/spine/server/delivery/Delivery.html#local--">local</a></span>()</code>
<div class="block">Creates a new instance of <code>Delivery</code> suitable for local and development environment.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="../../../../io/spine/server/delivery/Delivery.html" title="class in io.spine.server.delivery">Delivery</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../io/spine/server/delivery/Delivery.html#localAsync--">localAsync</a></span>()</code>
<div class="block">Creates a new instance of <code>Delivery</code> for local and development environment.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="../../../../io/spine/server/delivery/DeliveryBuilder.html" title="class in io.spine.server.delivery">DeliveryBuilder</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../io/spine/server/delivery/Delivery.html#newBuilder--">newBuilder</a></span>()</code>
<div class="block">Creates an instance of new <code>Builder</code> of <code>Delivery</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;I&gt;&nbsp;<a href="../../../../io/spine/server/delivery/CatchUpProcessBuilder.html" title="class in io.spine.server.delivery">CatchUpProcessBuilder</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../io/spine/server/delivery/Delivery.html#newCatchUpProcess-io.spine.server.projection.ProjectionRepository-">newCatchUpProcess</a></span>(<a href="../../../../io/spine/server/projection/ProjectionRepository.html" title="class in io.spine.server.projection">ProjectionRepository</a>&lt;I,?,?&gt;&nbsp;repo)</code>
<div class="block">Creates a new instance of the builder for <a href="../../../../io/spine/server/delivery/CatchUpProcess.html" title="class in io.spine.server.delivery"><code>CatchUpProcess</code></a>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;I&gt;&nbsp;<a href="../../../../io/spine/server/delivery/Inbox.Builder.html" title="class in io.spine.server.delivery">Inbox.Builder</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../io/spine/server/delivery/Delivery.html#newInbox-io.spine.type.TypeUrl-">newInbox</a></span>(io.spine.type.TypeUrl&nbsp;entityType)</code>
<div class="block">Creates an instance of <a href="../../../../io/spine/server/delivery/Inbox.Builder.html" title="class in io.spine.server.delivery"><code>Inbox.Builder</code></a> for the given entity type.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../io/spine/server/delivery/Delivery.html#subscribe-io.spine.server.delivery.ShardObserver-">subscribe</a></span>(<a href="../../../../io/spine/server/delivery/ShardObserver.html" title="interface in io.spine.server.delivery">ShardObserver</a>&nbsp;observer)</code>
<div class="block">Subscribes to the updates of shard contents.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.io.spine.logging.Logging">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;io.spine.logging.Logging</h3>
<code>_config, _debug, _error, _fine, _finer, _finest, _info, _severe, _trace, _warn, debugLevel, errorLevel, logger, loggerFor</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="newBuilder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newBuilder</h4>
<pre>public static&nbsp;<a href="../../../../io/spine/server/delivery/DeliveryBuilder.html" title="class in io.spine.server.delivery">DeliveryBuilder</a>&nbsp;newBuilder()</pre>
<div class="block">Creates an instance of new <code>Builder</code> of <code>Delivery</code>.</div>
</li>
</ul>
<a name="local--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>local</h4>
<pre>public static&nbsp;<a href="../../../../io/spine/server/delivery/Delivery.html" title="class in io.spine.server.delivery">Delivery</a>&nbsp;local()</pre>
<div class="block">Creates a new instance of <code>Delivery</code> suitable for local and development environment.

 <p>In this setup, the <code>InboxMessage</code>s are delivered to their targets synchronously.

 <p>Uses a <a href="../../../../io/spine/server/delivery/UniformAcrossAllShards.html#singleShard--">single-shard</a> splitting.

 <p>To construct a <code>Delivery</code> instance, a <code>StorageFactory</code> is needed.
 If it was not configured in the <code>ServerEnvironment</code>, uses a new <code>InMemoryStorageFactory</code>.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../io/spine/server/delivery/Delivery.html#localAsync--"><code>to create an asynchronous version of the local {@code Delivery}</code></a></dd>
</dl>
</li>
</ul>
<a name="localAsync--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>localAsync</h4>
<pre>public static&nbsp;<a href="../../../../io/spine/server/delivery/Delivery.html" title="class in io.spine.server.delivery">Delivery</a>&nbsp;localAsync()</pre>
<div class="block">Creates a new instance of <code>Delivery</code> for local and development environment.

 <p>The <code>InboxMessage</code>s are delivered to their targets asynchronously.

 <p>The returned instance of <code>Delivery</code> is configured to use
 <a href="../../../../io/spine/server/delivery/UniformAcrossAllShards.html#singleShard--">the single shard</a>.

 <p>To construct a <code>Delivery</code> instance, a <code>StorageFactory</code> is needed.
 If it was not configured in the <code>ServerEnvironment</code>, a new <code>InMemoryStorageFactory</code> used.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../io/spine/server/delivery/Delivery.html#local--"><code>to create a syncrhonous version of the local {@code Delivery}</code></a></dd>
</dl>
</li>
</ul>
<a name="deliverMessagesFrom-io.spine.server.delivery.ShardIndex-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deliverMessagesFrom</h4>
<pre>public&nbsp;java.util.Optional&lt;<a href="../../../../io/spine/server/delivery/DeliveryStats.html" title="class in io.spine.server.delivery">DeliveryStats</a>&gt;&nbsp;deliverMessagesFrom(io.spine.server.delivery.ShardIndex&nbsp;index)</pre>
<div class="block">Delivers the messages put into the shard with the passed index to their targets.

 <p>At a given moment of time, exactly one application node may serve messages from
 a particular shard. Therefore, in scope of this delivery, an approach based on pessimistic
 locking per-<code>ShardIndex</code> is applied.

 <p>In case the given shard is already processed by some node, this method does nothing and
 returns <code>Optional.empty()</code>.

 <p>The content of the shard is read and delivered on page-by-page basis. The runtime
 exceptions occurring while a page is being delivered are accumulated and then the first
 exception is rethrown, if any.

 <p>After all the pages are read, the delivery process is launched again for the same shard.
 It is required in order to handle the messages, that may have been put to the same shard
 as an outcome of the first-wave messages.

 <p>Once the shard has no more messages to deliver, the delivery process ends, releasing
 the lock for the respective <code>ShardIndex</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - the shard index to deliver the messages from.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the statistics on the performed delivery, or <code>Optional.empty()</code> if there
         were no delivery performed</dd>
</dl>
</li>
</ul>
<a name="newInbox-io.spine.type.TypeUrl-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newInbox</h4>
<pre>public&nbsp;&lt;I&gt;&nbsp;<a href="../../../../io/spine/server/delivery/Inbox.Builder.html" title="class in io.spine.server.delivery">Inbox.Builder</a>&lt;I&gt;&nbsp;newInbox(io.spine.type.TypeUrl&nbsp;entityType)</pre>
<div class="block">Creates an instance of <a href="../../../../io/spine/server/delivery/Inbox.Builder.html" title="class in io.spine.server.delivery"><code>Inbox.Builder</code></a> for the given entity type.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>I</code> - the type if entity identifiers</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>entityType</code> - the type of the entity, to which the inbox will belong</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the builder for the <code>Inbox</code></dd>
</dl>
</li>
</ul>
<a name="newCatchUpProcess-io.spine.server.projection.ProjectionRepository-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newCatchUpProcess</h4>
<pre>public&nbsp;&lt;I&gt;&nbsp;<a href="../../../../io/spine/server/delivery/CatchUpProcessBuilder.html" title="class in io.spine.server.delivery">CatchUpProcessBuilder</a>&lt;I&gt;&nbsp;newCatchUpProcess(<a href="../../../../io/spine/server/projection/ProjectionRepository.html" title="class in io.spine.server.projection">ProjectionRepository</a>&lt;I,?,?&gt;&nbsp;repo)</pre>
<div class="block">Creates a new instance of the builder for <a href="../../../../io/spine/server/delivery/CatchUpProcess.html" title="class in io.spine.server.delivery"><code>CatchUpProcess</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>I</code> - the type of identifiers of entities managed by the projection repository</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>repo</code> - projection repository for which the catch-up process will be created</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>new builder for the <code>CatchUpProcess</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-io.spine.server.delivery.ShardObserver-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>subscribe</h4>
<pre>public&nbsp;void&nbsp;subscribe(<a href="../../../../io/spine/server/delivery/ShardObserver.html" title="interface in io.spine.server.delivery">ShardObserver</a>&nbsp;observer)</pre>
<div class="block">Subscribes to the updates of shard contents.

 <p>The passed observer will be notified that the contents of a shard with a particular index
 were changed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>observer</code> - an observer to notify of updates.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../io/spine/server/delivery/CommandEndpoint.html" title="interface in io.spine.server.delivery"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../io/spine/server/delivery/DeliveryBuilder.html" title="class in io.spine.server.delivery"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?io/spine/server/delivery/Delivery.html" target="_top">Frames</a></li>
<li><a href="Delivery.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
