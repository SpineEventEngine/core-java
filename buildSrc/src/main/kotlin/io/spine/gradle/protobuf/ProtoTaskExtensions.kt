/*
 * Copyright 2025, TeamDev. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.spine.gradle.protobuf

import com.google.protobuf.gradle.GenerateProtoTask
import com.google.protobuf.gradle.ProtobufExtension
import io.spine.gradle.sourceSets
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.StandardOpenOption.TRUNCATE_EXISTING
import org.gradle.api.Project
import org.gradle.api.file.SourceDirectorySet
import org.gradle.api.tasks.SourceSet
import org.gradle.kotlin.dsl.get
import org.gradle.kotlin.dsl.getByType
import org.gradle.plugins.ide.idea.GenerateIdeaModule
import org.gradle.plugins.ide.idea.model.IdeaModel
import org.gradle.plugins.ide.idea.model.IdeaModule
import org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask
import titleCaseFirstChar

/**
 * Obtains the path of the `generated` directory under the project root directory.
 */
private val Project.generatedDir: Path
    get() = projectDir.resolve("generated").toPath()

/**
 * Obtains the `generated` directory for the source set of the task.
 *
 * If [language] is specified returns the subdirectory for this language.
 */
private fun GenerateProtoTask.generatedDir(language: String = ""): File {
    val path = "${project.generatedDir}/${sourceSet.name}/$language"
    return File(path)
}

/**
 * Configures a [GenerateProtoTask] for the code which cannot use Spine Model Compiler
 * (e.g., Spine Base or Spine Validation modules).
 *
 * The task configuration consists of the following steps:
 *
 * 1. Adding `"kotlin"` to the list of involved `protoc` builtins.
 *
 * 2. Turning on the generation of a descriptor set file for each source set.
 *    These files are placed under the `build/descriptors` directory.
 *
 * 3. Removing source code generated for `com.google` package for both Java and Kotlin.
 *    This is done at the final steps of the code generation.
 *
 * 4. Making `processResource` tasks depend on corresponding `generateProto` tasks.
 *    If the source set of the configured task isn't `main`, appropriate infix for
 *    the task names is used.
 *
 * The usage of this extension in a <em>module build file</em> would be:
 * ```
 *  protobuf {
 *      generateProtoTasks.all().configureEach {
 *         setup()
 *     }
 * }
 * ```
 * Using the same code under `subprojects` in a root build file does not seem to work because
 * test descriptor set files are not copied to resources. Performing this configuration from
 * a module build script solves the issue.
 *
 * IMPORTANT: In addition to calling `setup`, a submodule must contain a descriptor set reference
 * file (`desc.ref`) files placed under `resources`. The descriptor reference file must contain
 * a reference to the descriptor set file generated by the corresponding `GenerateProtoTask`.
 *
 * For example, for the `test` source set, the reference would be `known_types_test.desc`, and
 * for the `main` source set, the reference would be `known_types_main.desc`.
 *
 * See `io.spine.code.proto.DescriptorReference` and `io.spine.code.proto.FileDescriptors` classes
 * under the `base` project for more details.
 */
@Suppress("unused")
fun GenerateProtoTask.setup() {
    builtins.maybeCreate("kotlin")
    setupDescriptorSetFileCreation()

    doLast {
        copyGeneratedFiles()
    }

    excludeProtocOutput()

    setupKotlinCompile()
    dependOnProcessResourcesTask()
    makeDirsForIdeaModule()
}

/**
 * Tell `protoc` to generate descriptor set files under the project build dir.
 *
 * The name of the descriptor set file to be generated
 * is made to be unique via the project's Maven coordinates.
 *
 * As the last step of this task, writes a `desc.ref` file
 * for the contextual source set, pointing to the generated descriptor set file.
 * This is needed to allow other Spine libraries to locate and load the generated
 * descriptor set files properly.
 *
 * Such a job is usually performed by Spine McJava plugin;
 * however, it is not possible to use this plugin (or its code)
 * in this repository due to cyclic dependencies.
 */
@Suppress(
    "TooGenericExceptionCaught" /* Handling all file-writing failures in the same way.*/
)
fun GenerateProtoTask.setupDescriptorSetFileCreation() {
    // Tell `protoc` generate a descriptor set file.
    // The name of the generated file reflects the Maven coordinates of the project.
    val ssn = sourceSet.name
    generateDescriptorSet = true
    val buildDir = project.layout.buildDirectory.asFile.get().path
    val descriptorsDir = "$buildDir/descriptors/${ssn}"
    val descriptorName = project.descriptorSetName(sourceSet)
    with(descriptorSetOptions) {
        path = "$descriptorsDir/$descriptorName"
        includeImports = true
        includeSourceInfo = true
    }

    // Add the descriptor set file into the resources.
    project.sourceSets.named(ssn) {
        resources.srcDirs(descriptorsDir)
    }

    // Create a `desc.ref` in the same resource folder,
    // with the name of the descriptor set file created above.
    this.doLast {
        val descRefFile = File(descriptorsDir, "desc.ref")
        descRefFile.createNewFile()
        try {
            Files.write(descRefFile.toPath(), setOf(descriptorName), TRUNCATE_EXISTING)
        } catch (e: Exception) {
            project.logger.error("Error writing `${descRefFile.absolutePath}`.", e)
            throw e
        }
    }
}

/**
 * Returns a name of the descriptor file for the given [sourceSet],
 * reflecting the Maven coordinates of Gradle artifact, and the source set
 * for which the descriptor set name is to be generated.
 *
 * The returned value is just a file name and does not contain a file path.
 */
private fun Project.descriptorSetName(sourceSet: SourceSet) =
    arrayOf(
        group.toString(),
        name,
        sourceSet.name,
        version.toString()
    ).joinToString(separator = "_", postfix = ".desc")

/**
 * Copies files from the [outputBaseDir][GenerateProtoTask.outputBaseDir] into
 * a subdirectory of [generatedDir][Project.generatedDir] for
 * the current [sourceSet][GenerateProtoTask.sourceSet].
 *
 * Also removes sources belonging to the `com.google` package in the target directory.
 */
private fun GenerateProtoTask.copyGeneratedFiles() {
    project.copy {
        from(outputBaseDir)
        into(generatedDir())
    }
    deleteComGoogle("java")
    deleteComGoogle("kotlin")
}

/**
 * Remove the code generated for Google Protobuf library types.
 *
 * Java code for the `com.google` package was generated because we wanted
 * to have descriptors for all the types, including those from Google Protobuf library.
 * We want all the descriptors so that they are included into the resources used by
 * the `io.spine.type.KnownTypes` class.
 *
 * Now, as we have the descriptors _and_ excessive Java or Kotlin code, we delete it to avoid
 * classes that duplicate those coming from Protobuf library JARs.
 */
private fun GenerateProtoTask.deleteComGoogle(language: String) {
    val comDirectory = generatedDir(language).resolve("com")
    val googlePackage = comDirectory.resolve("google")

    project.delete(googlePackage)

    // If the `com` directory becomes empty, delete it too.
    if (comDirectory.exists() && comDirectory.isDirectory && comDirectory.list()!!.isEmpty()) {
        project.delete(comDirectory)
    }
}

/**
 * Exclude [GenerateProtoTask.outputBaseDir] from Java source set directories to avoid
 * duplicated source code files.
 */
fun GenerateProtoTask.excludeProtocOutput() {
    val protocOutputDir = File(outputBaseDir).parentFile
    val java: SourceDirectorySet = sourceSet.java

    // Filter out directories belonging to `build/generated/source/proto`.
    val newSourceDirectories = java.sourceDirectories
        .filter { !it.residesIn(protocOutputDir) }
        .toSet()
    // Make sure we start from scratch.
    // Not doing this failed the following, real, assignment sometimes.
    java.setSrcDirs(listOf<String>())
    java.srcDirs(newSourceDirectories)

    // Add copied files to the Java source set.
    java.srcDir(generatedDir("java"))
    java.srcDir(generatedDir("kotlin"))
}

/**
 * Make sure Kotlin compilation explicitly depends on this `GenerateProtoTask` to avoid racing.
 */
fun GenerateProtoTask.setupKotlinCompile() {
    val kotlinCompile = project.kotlinCompilationTaskFor(sourceSet)
    kotlinCompile?.dependsOn(this)
}

/**
 * Make the tasks `processResources` depend on `generateProto` tasks explicitly so that:
 *  1) Descriptor set files get into resources, avoiding the racing conditions
 *     during the build.
 *
 *  2) We don't have the warning "Execution optimizations have been disabled..." issued
 *     by Gradle during the build because Protobuf Gradle Plugin does not set
 *     dependencies between `generateProto` and `processResources` tasks.
 */
fun GenerateProtoTask.dependOnProcessResourcesTask() {
    val processResources = processResourceTaskName(sourceSet.name)
    project.tasks[processResources].dependsOn(this)
}

/**
 * Obtains the name of the `processResource` task for the given source set name.
 */
private fun processResourceTaskName(sourceSetName: String): String {
    val infix =
        if (sourceSetName == "main") ""
        else sourceSetName.titleCaseFirstChar()
    return "process${infix}Resources"
}

private fun Project.kotlinCompilationTaskFor(sourceSet: SourceSet): KotlinCompilationTask<*>? {
    val taskName = sourceSet.getCompileTaskName("Kotlin")
    return tasks.named(taskName, KotlinCompilationTask::class.java).orNull
}

private fun File.residesIn(directory: File): Boolean =
    canonicalFile.startsWith(directory.absolutePath)

/**
 * Ensures that generated directories for Java and Kotlin are created before [GenerateIdeaModule].
 *
 * This works as advised by `Utils.groovy` from Protobuf Gradle plugin:
 * ```
 * This is required because the IntelliJ IDEA plugin does not allow adding source directories
 * that do not exist. The IntelliJ IDEA config files should be valid from the start even if
 * a user runs './gradlew idea' before running './gradlew generateProto'.
 * ```
 */
fun GenerateProtoTask.makeDirsForIdeaModule() {
    project.plugins.withId("idea") {
        val javaDir = generatedDir("java")
        val kotlinDir = generatedDir("kotlin")
        project.tasks.withType(GenerateIdeaModule::class.java).forEach {
            it.doFirst {
                javaDir.mkdirs()
                kotlinDir.mkdirs()
            }
        }
    }
}

/**
 * Prints diagnostic output of `sourceDirs` and `generatedSourceDirs` of an [IdeaModule].
 *
 * To get a handle on [IdeaModule] please use the following code:
 *
 * ```kotlin
 * val module = project.extensions.findByType(IdeaModel::class.java)!!.module
 * ```
 */
@Suppress("unused") // To be used when debugging build scripts.
fun IdeaModule.printSourceDirectories() {
    println("**** [IDEA] Source directories:")
    sourceDirs.forEach { println(it) }
    println()
    println("**** [IDEA] Generated source directories:")
    generatedSourceDirs.forEach { println(it) }
    println()
    println("**** [IDEA] Excluded directories:")
    excludeDirs.forEach { println(it) }
}

/**
 * Obtains the directory where the Protobuf Gradle Plugin should place the generated code.
 *
 * The directory is fixed to be `$buildDir/generated/source/proto` and cannot be
 * changed by the settings of the plugin. Even though [ProtobufExtension] has a property
 * [generatedFilesBaseDir][ProtobufExtension.getGeneratedFilesBaseDir], which is supposed
 * to be used for this purpose, it is declared with `@PackageScope` and thus cannot be
 * accessed from outside the plugin. The Protobuf Gradle Plugin (at v0.9.2) does not
 * modify the value of the property either.
 */
val Project.generatedSourceProtoDir: Path
    get() = layout.buildDirectory.dir("generated/source/proto").get().asFile.toPath()

/**
 * Ensures that the sources generated by Protobuf Gradle Plugin
 * are not included in the IDEA project.
 *
 * IDEA should only see the sources generated by ProtoData as
 * we define in [GenerateProtoTask.excludeProtocOutput].
 */
@Suppress("unused")
fun Project.configureIdea() {

    fun filterSources(sources: Set<File>, excludeDir: File): Set<File> =
        sources.filter { !it.residesIn(excludeDir) }.toSet()

    pluginManager.withPlugin("idea") {
        val idea = extensions.getByType<IdeaModel>()
        with(idea.module) {
            val protocOutput = file(generatedSourceProtoDir)
            val protocTargets = protocTargets()
            excludeWithNested(protocOutput.toPath(), protocTargets)
            sourceDirs = filterSources(sourceDirs, protocOutput)
            testSources.filter { !it.residesIn(protocOutput) }
            generatedSourceDirs = generatedDir.resolve(protocTargets)
                .map { it.toFile() }
                .toSet()
        }
    }
}

/**
 * Lists target directories for Protobuf code generation.
 *
 * The directory names are in the following format:
 *
 * `<source-set-name>/<builtIn-or-plugin-name>`
 */
private fun Project.protocTargets(): List<Path> {
    val protobufTasks = tasks.withType(GenerateProtoTask::class.java)
    val codegenTargets = sequence {
        protobufTasks.forEach { task ->
            val sourceSet = task.sourceSet.name
            val builtins = task.builtins.map { builtin -> builtin.name }
            val plugins = task.plugins.map { plugin -> plugin.name }
            val combined = builtins + plugins
            combined.forEach { subdir ->
                yield(Paths.get(sourceSet, subdir))
            }
        }
    }
    return codegenTargets.toList()
}

private fun Path.resolve(subdirs: Iterable<Path>): List<Path> =
    subdirs.map {
        resolve(it)
    }

/**
 * Excludes the given directory and its subdirectories from
 * being seen as ones with the source code.
 *
 * The primary use of this extension is to exclude `build/generated/source/proto` and its
 * subdirectories to avoid duplication of types in the generated code with those in
 * produced by ProtoData under the `$projectDir/generated/` directory.
 */
private fun IdeaModule.excludeWithNested(directory: Path, subdirs: Iterable<Path>) {
    excludeDirs.add(directory.toFile())
    directory.resolve(subdirs).forEach {
        excludeDirs.add(it.toFile())
    }
}

@Suppress("unused") // To be used when debugging build scripts.
private fun printExcluded(dir: Any) {
    println("  [IDEA] Excluding directory: $dir")
}
