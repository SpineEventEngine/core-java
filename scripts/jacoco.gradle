/*
 * Copyright 2018, TeamDev Ltd. All rights reserved.
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Apply this script to enable JaCoCo test report.
//
// This task aggregates the XML report results from all the subprojects.
// Inspired by: https://gist.github.com/aalmiray/e6f54aa4b3803be0bcac

// Required to grab dependencies for `jacocoRootReport` task.
repositories {
    mavenCentral()
}

import groovy.io.FileType


/**
 * Serves to distinguish the {@code .java} and {@code .class} files built from the Protobuf definitions
 * from the human-created production code.
 */
class CodebaseFilter {

    private static final String GENERATED_PATH_MARKER = "generated"

    private static final String JAVA_SRC_FOLDER_MARKER = "/java/"
    private static final String GRPC_SRC_FOLDER_MARKER = "/main/grpc/"

    private static final String JAVA_OUTPUT_FOLDER_MARKER = "/main/"

    private static final String JAVA_SOURCE_FILE_EXTENSION = ".java"
    private static final String COMPILED_CLASS_FILE_EXTENSION = ".class"
    private static final String ANONYMOUS_CLASS_MARKER = '$'
    private static final String ANONYMOUS_CLASS_PATTERN = "\\${ANONYMOUS_CLASS_MARKER}"

    private final Project project
    private final def javaSrcDirs
    private final def outputDirs

    CodebaseFilter(final Project project, final javaSrcDirs, final outputDirs) {
        this.project = project
        this.javaSrcDirs = javaSrcDirs
        this.outputDirs = outputDirs
    }

    static FileCollection nonGeneratedOnly(final FileCollection files) {
        return files.filter {
            !it.absolutePath.contains(GENERATED_PATH_MARKER)
        }
    }

    static FileCollection generatedOnly(final FileCollection files) {
        return files.filter {
            it.absolutePath.contains(GENERATED_PATH_MARKER)
        }
    }

    private static String parseClassName(
            final File file, final String sourceFolderMarker, final String extension) {

        final def index = file.absolutePath.lastIndexOf(sourceFolderMarker)
        if (index > 0) {
            def filePathInFolder = file.absolutePath.substring(index + sourceFolderMarker.length())
            if (filePathInFolder.endsWith(extension)) {
                filePathInFolder = filePathInFolder.substring(0, filePathInFolder.length() - extension.length())

                final def className = filePathInFolder.replace('/', '.')
                return className
            } else {
                return null
            }
        } else {
            return null
        }
    }

    @SuppressWarnings("GroovyAssignabilityCheck")
    // a workaround for https://youtrack.jetbrains.com/issue/IDEA-141744
    private LinkedList<String> getGeneratedClassNames() {
        final def sourceFiles = project.files(javaSrcDirs)
        final def generatedSourceFiles = generatedOnly(sourceFiles)

        final def generatedClassNames = new LinkedList<String>()
        generatedSourceFiles.each { final folder ->
            if (folder.exists() && folder.isDirectory()) {
                folder.eachFileRecurse(FileType.FILES) { final aFile ->
                    final
                    def name = parseClassName(aFile, JAVA_SRC_FOLDER_MARKER, JAVA_SOURCE_FILE_EXTENSION)
                    if (name != null) {
                        generatedClassNames.add(name)
                    } else {
                        // try another folder prefix; perhaps this file is gRPC service.
                        final def generatedByGrpc = parseClassName(aFile,
                                GRPC_SRC_FOLDER_MARKER,
                                JAVA_SOURCE_FILE_EXTENSION)
                        if (generatedByGrpc != null) {
                            generatedClassNames.add(generatedByGrpc)
                        }
                    }
                }
            }
        }

        return generatedClassNames
    }

    @SuppressWarnings("GroovyAssignabilityCheck")
    // a workaround for https://youtrack.jetbrains.com/issue/IDEA-141744
    List<FileTree> findNonGeneratedCompiledFiles() {
        println(" - Available source dirs: ")
        final def srcDirs = project.files(javaSrcDirs)
        srcDirs.each {
            println " --- ${it}"
        }

        final def generatedClassNames = getGeneratedClassNames()
        final def nonGeneratedClassTree = outputDirs.collect {
            println("Filtering out the generated classes for ${it.getClassesDir()}")

            // return the filtered `fileTree`s as a collected result.
            project.fileTree(dir: it.getClassesDir(), exclude: { final details ->
                final def file = details.file
                def className = parseClassName(file, JAVA_OUTPUT_FOLDER_MARKER, COMPILED_CLASS_FILE_EXTENSION)

                // Handling anonymous classes as well.
                // They should be associated with the same `.java` file as their parent class.
                if (className != null && className.contains(ANONYMOUS_CLASS_MARKER)) {
                    //assuming there cannot be more that a single `$`.
                    className = className.split(ANONYMOUS_CLASS_PATTERN)[0]
                }
                generatedClassNames.contains(className)
            })
        }
        return nonGeneratedClassTree
    }
}

// Create an aggregate coverage report across modules, excluding the generated content from the coverage stats.
//
task jacocoRootReport(dependsOn: subprojects.test, type: JacocoReport) {
    additionalSourceDirs = CodebaseFilter.nonGeneratedOnly(files(subprojects.sourceSets.main.java.srcDirs))
    sourceDirectories = CodebaseFilter.nonGeneratedOnly(files(subprojects.sourceSets.main.java.srcDirs))

    // It is required to set some default value in order for the task to initialize.
    // This value is overridden in `#doFirst` section.
    classDirectories = files(subprojects.sourceSets.main.output)
    executionData = files(subprojects.jacocoTestReport.executionData)
    reports {
        html.enabled = true
        xml.enabled = true
        csv.enabled = false
    }
    onlyIf = {
        true
    }
    doFirst {
        // In case some modules do not have the JaCoCo execution data files.
        executionData = files(executionData.findAll {
            it.exists()
        })

        println("Starting to compose an aggregate coverage report across modules.")

        final def filter = new CodebaseFilter(project,
                subprojects.sourceSets.main.java.srcDirs,
                subprojects.sourceSets.main.output)
        final def nonGeneratedFiles = filter.findNonGeneratedCompiledFiles()
        classDirectories = files(nonGeneratedFiles)
    }
}

check.dependsOn jacocoRootReport
